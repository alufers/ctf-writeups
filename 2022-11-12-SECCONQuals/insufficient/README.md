# insufficient

We start with a random 512 bit prime `p`.
The script selects random 8 coefficients `c[i]` from `range(2**128)`. As output, we get their concatenation xored with flag. Additionaly, for 4 tuples `(x, y, z)` of random integers (x, y is from `range(p)` and z is from `range(2**128)`). we receive x, y along with the value of polynomial
```
f(x, y, z) = c[0]*x + c[1]*x^2 + c[2]*x^3
           + c[3]*y + c[4]*y^2 + c[5]*y^3
           + c[6]*z + c[7] mod p
``` 


We started with linearizing the polynomial by introducing variables `x'=x`, `x''=x^2`, `x'''=x^3`, etc.
This leads to a matrix equation (x0, y0, ... are the values that were sampled):
```
A = [ c[0]  c[1]  c[2]  c[3]  c[4]  c[5]  1  0  0  0  -f(x0, y0, z0)]
    [ c[0]  c[1]  c[2]  c[3]  c[4]  c[5]  0  1  0  0  -f(x1, y1, z1)]
    [ c[0]  c[1]  c[2]  c[3]  c[4]  c[5]  0  0  1  0  -f(x2, y2, z2)]
    [ c[0]  c[1]  c[2]  c[3]  c[4]  c[5]  0  0  0  1  -f(x3, y3, z3)]
```
Now, let
```
b = [ x'  x''  x'''  y'  y''  y'''  z0*c[6]+c[7]  0  0  0  1]
```
Such vector is element of the null space generated by solutions of `Ax=0`.

Note that `z0*c[6]+c[7]` is relatively small, ie. at most 257 bits. Therefore we can use the following matrix and find short vectors in it using LLL algorithm:
```
C = 2**128
m[0]  = [*(x    for (x, y), w in shares), C, 0, 0, 0, 0, 0, 0   ]
m[1]  = [*(x**2 for (x, y), w in shares), 0, C, 0, 0, 0, 0, 0   ]
m[2]  = [*(x**3 for (x, y), w in shares), 0, 0, C, 0, 0, 0, 0   ]
m[3]  = [*(y    for (x, y), w in shares), 0, 0, 0, C, 0, 0, 0   ]
m[4]  = [*(y**2 for (x, y), w in shares), 0, 0, 0, 0, C, 0, 0   ]
m[5]  = [*(y**3 for (x, y), w in shares), 0, 0, 0, 0, 0, C, 0   ]
m[6]  = [*(-w   for (x, y), w in shares), 0, 0, 0, 0, 0, 0, C**2]
m[7]  = [p, 0, 0, 0                     , 0, 0, 0, 0, 0, 0, 0   ]
m[8]  = [0, p, 0, 0                     , 0, 0, 0, 0, 0, 0, 0   ]
m[9]  = [0, 0, p, 0                     , 0, 0, 0, 0, 0, 0, 0   ]
m[10] = [0, 0, 0, p                     , 0, 0, 0, 0, 0, 0, 0   ]
```

The multiplier `C**2` is used so that the vector actually is short. `m[7:]` is because we have a modular equation - it can eliminate all the multiples of `p` added in the process.
The short vector we obtain is
```
[ -(z0*c[6]+c[7]) -(z1*c[6]+c[7]) -(z2*c[6]+c[7]) -(z3*c[6]+c[7]) x' x'' x''' y' y'' y''' ]
```
(after correcting for the multiplier `C` or its powers).

After running LLL, we receive a short vector which with high probability is the vector `c`. To recover two last coefficients, first observe that `c[6] = gcd((z0*c[6]+c[7]) - (z1*c[6]+c[7]), ((z2*c[6]+c[7]) - (z3*c[6]+c[7])))//2`. To recover `c[7]` we again use LLL, for equation `z0*c[6]+c[7] = know_value_of_lhs`.

In solve.sage file there is a solver script.
